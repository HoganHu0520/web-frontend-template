/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class DefectCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDefectCategory(id: number, type: string, languageCode: string): Observable<DefectCategoryDto> {
        let url_ = this.baseUrl + "/defect-category/get-defect-category/{id}/{type}/{languageCode}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (languageCode === undefined || languageCode === null)
            throw new Error("The parameter 'languageCode' must be defined.");
        url_ = url_.replace("{languageCode}", encodeURIComponent("" + languageCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDefectCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDefectCategory(<any>response_);
                } catch (e) {
                    return <Observable<DefectCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetDefectCategory(response: Response): Observable<DefectCategoryDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DefectCategoryDto.fromJS(resultData200) : new DefectCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number, type: string): Observable<void> {
        let url_ = this.baseUrl + "/defect-category/delete/{id}/{type}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPartners(type: string, languageCode: string): Observable<DefectCategoryDto[]> {
        let url_ = this.baseUrl + "/defect-category/get-all-partners/{type}/{languageCode}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (languageCode === undefined || languageCode === null)
            throw new Error("The parameter 'languageCode' must be defined.");
        url_ = url_.replace("{languageCode}", encodeURIComponent("" + languageCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPartners(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllPartners(<any>response_);
                } catch (e) {
                    return <Observable<DefectCategoryDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectCategoryDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPartners(response: Response): Observable<DefectCategoryDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DefectCategoryDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectCategoryDto[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    create(request: DefectCategoryDto): Observable<DefectCategoryDto> {
        let url_ = this.baseUrl + "/defect-category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DefectCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<DefectCategoryDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DefectCategoryDto.fromJS(resultData200) : new DefectCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectCategoryDto>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    update(request: DefectCategoryDto): Observable<DefectCategoryDto> {
        let url_ = this.baseUrl + "/defect-category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DefectCategoryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectCategoryDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<DefectCategoryDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DefectCategoryDto.fromJS(resultData200) : new DefectCategoryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectCategoryDto>(<any>null);
    }
}

@Injectable()
export class HelpdeskServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    config(): Observable<HelpdeskConfigModel> {
        let url_ = this.baseUrl + "/helpdesk/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processConfig(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processConfig(<any>response_);
                } catch (e) {
                    return <Observable<HelpdeskConfigModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<HelpdeskConfigModel>><any>Observable.throw(response_);
        });
    }

    protected processConfig(response: Response): Observable<HelpdeskConfigModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HelpdeskConfigModel.fromJS(resultData200) : new HelpdeskConfigModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HelpdeskConfigModel>(<any>null);
    }

    /**
     * @return Success
     */
    issueCategories(): Observable<HelpdeskIssueCategoryModel[]> {
        let url_ = this.baseUrl + "/helpdesk/issue-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processIssueCategories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssueCategories(<any>response_);
                } catch (e) {
                    return <Observable<HelpdeskIssueCategoryModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HelpdeskIssueCategoryModel[]>><any>Observable.throw(response_);
        });
    }

    protected processIssueCategories(response: Response): Observable<HelpdeskIssueCategoryModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HelpdeskIssueCategoryModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HelpdeskIssueCategoryModel[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateContact(request: HelpdeskConfigModel): Observable<void> {
        let url_ = this.baseUrl + "/helpdesk/update-contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateContact(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateContact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateContact(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @helpdeskIssueCategoryModel (optional) 
     * @return Success
     */
    createIssueCategory(helpdeskIssueCategoryModel: HelpdeskIssueCategoryModel): Observable<void> {
        let url_ = this.baseUrl + "/helpdesk/create-issue-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(helpdeskIssueCategoryModel);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateIssueCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateIssueCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateIssueCategory(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @helpdeskIssueCategoryModel (optional) 
     * @return Success
     */
    updateIssueCategory(helpdeskIssueCategoryModel: HelpdeskIssueCategoryModel): Observable<void> {
        let url_ = this.baseUrl + "/helpdesk/update-issue-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(helpdeskIssueCategoryModel);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateIssueCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateIssueCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateIssueCategory(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteIssueCategory(issueCategoryId: number): Observable<void> {
        let url_ = this.baseUrl + "/helpdesk/delete-issue-category/{issueCategoryId}";
        if (issueCategoryId === undefined || issueCategoryId === null)
            throw new Error("The parameter 'issueCategoryId' must be defined.");
        url_ = url_.replace("{issueCategoryId}", encodeURIComponent("" + issueCategoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteIssueCategory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteIssueCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteIssueCategory(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @helpdeskIssueModel (optional) 
     * @return Success
     */
    issue(helpdeskIssueModel: HelpdeskIssueModel): Observable<void> {
        let url_ = this.baseUrl + "/helpdesk/issue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(helpdeskIssueModel);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processIssue(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssue(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processIssue(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PartnerServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPartner(id: number, type: string): Observable<ProjectPartnerDto> {
        let url_ = this.baseUrl + "/partner/get-partner/{id}/{type}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPartner(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPartner(<any>response_);
                } catch (e) {
                    return <Observable<ProjectPartnerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectPartnerDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPartner(response: Response): Observable<ProjectPartnerDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectPartnerDto.fromJS(resultData200) : new ProjectPartnerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectPartnerDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number, type: string): Observable<void> {
        let url_ = this.baseUrl + "/partner/delete/{id}/{type}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPartners(type: string): Observable<ProjectPartnerDto[]> {
        let url_ = this.baseUrl + "/partner/get-all-partners/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPartners(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllPartners(<any>response_);
                } catch (e) {
                    return <Observable<ProjectPartnerDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectPartnerDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPartners(response: Response): Observable<ProjectPartnerDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProjectPartnerDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectPartnerDto[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    create(request: ProjectPartnerDto): Observable<ProjectPartnerDto> {
        let url_ = this.baseUrl + "/partner/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ProjectPartnerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectPartnerDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<ProjectPartnerDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectPartnerDto.fromJS(resultData200) : new ProjectPartnerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectPartnerDto>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    update(request: ProjectPartnerDto): Observable<ProjectPartnerDto> {
        let url_ = this.baseUrl + "/partner/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ProjectPartnerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectPartnerDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<ProjectPartnerDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectPartnerDto.fromJS(resultData200) : new ProjectPartnerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectPartnerDto>(<any>null);
    }
}

@Injectable()
export class ProjectManageServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getDailyTotalPendingDefects(projectId: number): Observable<TotalPendingDefectStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-daily-total-pending-defects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDailyTotalPendingDefects(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDailyTotalPendingDefects(<any>response_);
                } catch (e) {
                    return <Observable<TotalPendingDefectStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<TotalPendingDefectStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetDailyTotalPendingDefects(response: Response): Observable<TotalPendingDefectStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TotalPendingDefectStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TotalPendingDefectStatisticDto[]>(<any>null);
    }

    /**
     * @projectIds (optional) 
     * @return Success
     */
    getAvgCustomerReportedDefectsByCmCompany(projectIds: number[]): Observable<PartnerReportStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-avg-customer-reported-defects-by-cm-company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectIds);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAvgCustomerReportedDefectsByCmCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAvgCustomerReportedDefectsByCmCompany(<any>response_);
                } catch (e) {
                    return <Observable<PartnerReportStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PartnerReportStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAvgCustomerReportedDefectsByCmCompany(response: Response): Observable<PartnerReportStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartnerReportStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PartnerReportStatisticDto[]>(<any>null);
    }

    /**
     * @projectIds (optional) 
     * @return Success
     */
    getAvgCustomerReportedDefectsByContractorCompany(projectIds: number[]): Observable<PartnerReportStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-avg-customer-reported-defects-by-contractor-company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectIds);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAvgCustomerReportedDefectsByContractorCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAvgCustomerReportedDefectsByContractorCompany(<any>response_);
                } catch (e) {
                    return <Observable<PartnerReportStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<PartnerReportStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAvgCustomerReportedDefectsByContractorCompany(response: Response): Observable<PartnerReportStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartnerReportStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PartnerReportStatisticDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProjectUnitMonthStatus(projectId: number): Observable<UnitStatusStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-project-unit-month-status/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjectUnitMonthStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjectUnitMonthStatus(<any>response_);
                } catch (e) {
                    return <Observable<UnitStatusStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UnitStatusStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetProjectUnitMonthStatus(response: Response): Observable<UnitStatusStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UnitStatusStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UnitStatusStatisticDto[]>(<any>null);
    }

    /**
     * @projectIds (optional) 
     * @return Success
     */
    getUnitsTransferred(projectIds: number[]): Observable<UnitTransferredDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-units-transferred";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectIds);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUnitsTransferred(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUnitsTransferred(<any>response_);
                } catch (e) {
                    return <Observable<UnitTransferredDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UnitTransferredDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetUnitsTransferred(response: Response): Observable<UnitTransferredDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UnitTransferredDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UnitTransferredDto[]>(<any>null);
    }

    /**
     * @projectIds (optional) 
     * @return Success
     */
    getAvgDefectsPerUnitStatistics(projectIds: number[]): Observable<AvgDefectsPerUnitStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-avg-defects-per-unit-statistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectIds);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAvgDefectsPerUnitStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAvgDefectsPerUnitStatistics(<any>response_);
                } catch (e) {
                    return <Observable<AvgDefectsPerUnitStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<AvgDefectsPerUnitStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAvgDefectsPerUnitStatistics(response: Response): Observable<AvgDefectsPerUnitStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AvgDefectsPerUnitStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AvgDefectsPerUnitStatisticDto[]>(<any>null);
    }

    /**
     * @projectIds (optional) 
     * @return Success
     */
    getMultipleProjectsUnitStatusStatistics(projectIds: number[]): Observable<UnitStatusStatisticDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-multiple-projects-unit-status-statistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(projectIds);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetMultipleProjectsUnitStatusStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetMultipleProjectsUnitStatusStatistics(<any>response_);
                } catch (e) {
                    return <Observable<UnitStatusStatisticDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UnitStatusStatisticDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMultipleProjectsUnitStatusStatistics(response: Response): Observable<UnitStatusStatisticDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UnitStatusStatisticDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UnitStatusStatisticDto[]>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTopCs(id: number): Observable<TopCSModel[]> {
        let url_ = this.baseUrl + "/project-manage/get-top-cs?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetTopCs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetTopCs(<any>response_);
                } catch (e) {
                    return <Observable<TopCSModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<TopCSModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTopCs(response: Response): Observable<TopCSModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(TopCSModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TopCSModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProjectStatistics(id: number, groupBy: string): Observable<DefectStatisticModel[]> {
        let url_ = this.baseUrl + "/project-manage/get-project-statistics/{id}/{groupBy}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (groupBy === undefined || groupBy === null)
            throw new Error("The parameter 'groupBy' must be defined.");
        url_ = url_.replace("{groupBy}", encodeURIComponent("" + groupBy)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjectStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjectStatistics(<any>response_);
                } catch (e) {
                    return <Observable<DefectStatisticModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectStatisticModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetProjectStatistics(response: Response): Observable<DefectStatisticModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(DefectStatisticModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectStatisticModel[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    getProjects(request: ProjectSearchDto): Observable<PagedResultDtoOfProjectSummaryDto> {
        let url_ = this.baseUrl + "/project-manage/get-projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjects(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjects(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectSummaryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectSummaryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetProjects(response: Response): Observable<PagedResultDtoOfProjectSummaryDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfProjectSummaryDto.fromJS(resultData200) : new PagedResultDtoOfProjectSummaryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfProjectSummaryDto>(<any>null);
    }

    /**
     * @return Success
     */
    getProject(projectId: number): Observable<ProjectDetailDto> {
        let url_ = this.baseUrl + "/project-manage/get-project/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProject(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProject(<any>response_);
                } catch (e) {
                    return <Observable<ProjectDetailDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectDetailDto>><any>Observable.throw(response_);
        });
    }

    protected processGetProject(response: Response): Observable<ProjectDetailDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectDetailDto.fromJS(resultData200) : new ProjectDetailDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectDetailDto>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    createProject(request: ProjectDetailDto): Observable<ErrorDto[]> {
        let url_ = this.baseUrl + "/project-manage/create-project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateProject(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateProject(<any>response_);
                } catch (e) {
                    return <Observable<ErrorDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ErrorDto[]>><any>Observable.throw(response_);
        });
    }

    protected processCreateProject(response: Response): Observable<ErrorDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ErrorDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ErrorDto[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    updateProject(request: ProjectDetailDto): Observable<ErrorDto[]> {
        let url_ = this.baseUrl + "/project-manage/update-project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProject(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateProject(<any>response_);
                } catch (e) {
                    return <Observable<ErrorDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ErrorDto[]>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProject(response: Response): Observable<ErrorDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ErrorDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ErrorDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    delete(projectId: number): Observable<void> {
        let url_ = this.baseUrl + "/project-manage/delete/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    getLayout(request: ProjectLayoutSearchDto): Observable<PagedResultDtoOfProjectLayoutDto> {
        let url_ = this.baseUrl + "/project-manage/get-layout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetLayout(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetLayout(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfProjectLayoutDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfProjectLayoutDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLayout(response: Response): Observable<PagedResultDtoOfProjectLayoutDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfProjectLayoutDto.fromJS(resultData200) : new PagedResultDtoOfProjectLayoutDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfProjectLayoutDto>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    importLayout(request: ProjectLayoutDto[], projectId: number, isUpdate: boolean): Observable<ImportLayoutErrorResponse[]> {
        let url_ = this.baseUrl + "/project-manage/import-layout/{projectId}/{isUpdate}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        if (isUpdate === undefined || isUpdate === null)
            throw new Error("The parameter 'isUpdate' must be defined.");
        url_ = url_.replace("{isUpdate}", encodeURIComponent("" + isUpdate)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processImportLayout(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processImportLayout(<any>response_);
                } catch (e) {
                    return <Observable<ImportLayoutErrorResponse[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImportLayoutErrorResponse[]>><any>Observable.throw(response_);
        });
    }

    protected processImportLayout(response: Response): Observable<ImportLayoutErrorResponse[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ImportLayoutErrorResponse.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ImportLayoutErrorResponse[]>(<any>null);
    }

    /**
     * @return Success
     */
    exportUnitStatus(projectId: number): Observable<ExportUrlDto> {
        let url_ = this.baseUrl + "/project-manage/export-unit-status/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processExportUnitStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExportUnitStatus(<any>response_);
                } catch (e) {
                    return <Observable<ExportUrlDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExportUrlDto>><any>Observable.throw(response_);
        });
    }

    protected processExportUnitStatus(response: Response): Observable<ExportUrlDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExportUrlDto.fromJS(resultData200) : new ExportUrlDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExportUrlDto>(<any>null);
    }

    /**
     * @projectId (optional) 
     * @return Success
     */
    getUnitStatus(projectId: number): Observable<ProjectBuildingStatusReportDto[]> {
        let url_ = this.baseUrl + "/project-manage/get-unit-status?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUnitStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUnitStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectBuildingStatusReportDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectBuildingStatusReportDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetUnitStatus(response: Response): Observable<ProjectBuildingStatusReportDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProjectBuildingStatusReportDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectBuildingStatusReportDto[]>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    getProjectDefects(request: ProjectDefectsSearchDto): Observable<PagedResultDtoOfDefectSummaryDto> {
        let url_ = this.baseUrl + "/project-manage/get-project-defects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjectDefects(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjectDefects(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDefectSummaryDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfDefectSummaryDto>><any>Observable.throw(response_);
        });
    }

    protected processGetProjectDefects(response: Response): Observable<PagedResultDtoOfDefectSummaryDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDefectSummaryDto.fromJS(resultData200) : new PagedResultDtoOfDefectSummaryDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfDefectSummaryDto>(<any>null);
    }

    /**
     * @return Success
     */
    getGlobalSettings(): Observable<GlobalSettingDto> {
        let url_ = this.baseUrl + "/project-manage/get-global-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetGlobalSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetGlobalSettings(<any>response_);
                } catch (e) {
                    return <Observable<GlobalSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<GlobalSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processGetGlobalSettings(response: Response): Observable<GlobalSettingDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GlobalSettingDto.fromJS(resultData200) : new GlobalSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GlobalSettingDto>(<any>null);
    }

    /**
     * @return Success
     */
    getProjectSettings(projectId: number): Observable<ProjectSettingDto> {
        let url_ = this.baseUrl + "/project-manage/get-project-settings/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjectSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjectSettings(<any>response_);
                } catch (e) {
                    return <Observable<ProjectSettingDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectSettingDto>><any>Observable.throw(response_);
        });
    }

    protected processGetProjectSettings(response: Response): Observable<ProjectSettingDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectSettingDto.fromJS(resultData200) : new ProjectSettingDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectSettingDto>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    getProjectCustomers(request: CustomerSearchDto): Observable<PagedResultDtoOfCustomerDto> {
        let url_ = this.baseUrl + "/project-manage/get-project-customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetProjectCustomers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetProjectCustomers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerDto>><any>Observable.throw(response_);
        });
    }

    protected processGetProjectCustomers(response: Response): Observable<PagedResultDtoOfCustomerDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCustomerDto.fromJS(resultData200) : new PagedResultDtoOfCustomerDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfCustomerDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefect(id: number): Observable<DefectDetailModel> {
        let url_ = this.baseUrl + "/project-manage/get-defect/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetDefect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetDefect(<any>response_);
                } catch (e) {
                    return <Observable<DefectDetailModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<DefectDetailModel>><any>Observable.throw(response_);
        });
    }

    protected processGetDefect(response: Response): Observable<DefectDetailModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DefectDetailModel.fromJS(resultData200) : new DefectDetailModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DefectDetailModel>(<any>null);
    }
}

@Injectable()
export class QrCodeServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    generateQrcode(projectId: number): Observable<void> {
        let url_ = this.baseUrl + "/QrCode/generate-qrcode/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGenerateQrcode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGenerateQrcode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGenerateQrcode(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @criteria (optional) 
     * @return Success
     */
    getQrcodeWord(criteria: PrintQrCodeCriteria): Observable<ExportUrlDto> {
        let url_ = this.baseUrl + "/QrCode/get-qrcode-word";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(criteria);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetQrcodeWord(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetQrcodeWord(<any>response_);
                } catch (e) {
                    return <Observable<ExportUrlDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExportUrlDto>><any>Observable.throw(response_);
        });
    }

    protected processGetQrcodeWord(response: Response): Observable<ExportUrlDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExportUrlDto.fromJS(resultData200) : new ExportUrlDto();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExportUrlDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentLoginInformations(response: Response): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class UsersServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getPermissionMatrix(): Observable<RolePermissionMatrixDto[]> {
        let url_ = this.baseUrl + "/users/get-permission-matrix";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPermissionMatrix(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPermissionMatrix(<any>response_);
                } catch (e) {
                    return <Observable<RolePermissionMatrixDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<RolePermissionMatrixDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetPermissionMatrix(response: Response): Observable<RolePermissionMatrixDto[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RolePermissionMatrixDto.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RolePermissionMatrixDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    get(userId: number): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/get/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @search (optional) 
     * @return Success
     */
    getUsers(search: UserSearchModel): Observable<PagedResultDtoOfUserModel> {
        let url_ = this.baseUrl + "/users/getUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(search);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserModel>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: Response): Observable<PagedResultDtoOfUserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserModel.fromJS(resultData200) : new PagedResultDtoOfUserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserModel>(<any>null);
    }

    /**
     * @return Success
     */
    delete(userId: number): Observable<void> {
        let url_ = this.baseUrl + "/users/delete/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    disable(userId: number): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/disable/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDisable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDisable(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processDisable(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @return Success
     */
    enable(userId: number): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/enable/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processEnable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEnable(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processEnable(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @user (optional) 
     * @return Success
     */
    update(user: UserRequestModel): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @user (optional) 
     * @return Success
     */
    create(user: UserRequestModel): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @user (optional) 
     * @return Success
     */
    resendInitialPassword(user: UserRequestModel): Observable<void> {
        let url_ = this.baseUrl + "/users/resend-initial-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResendInitialPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResendInitialPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResendInitialPassword(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleModel[]> {
        let url_ = this.baseUrl + "/users/getRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<RoleModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<RoleModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: Response): Observable<RoleModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(RoleModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RoleModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    userinfo(): Observable<UserModel> {
        let url_ = this.baseUrl + "/users/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUserinfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUserinfo(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserModel>><any>Observable.throw(response_);
        });
    }

    protected processUserinfo(response: Response): Observable<UserModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserModel.fromJS(resultData200) : new UserModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserModel>(<any>null);
    }

    /**
     * @userId (optional) 
     * @return Success
     */
    getUserAssignedProjects(userId: number): Observable<ProjectSummaryModel[]> {
        let url_ = this.baseUrl + "/users/get-user-assigned-projects?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserAssignedProjects(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserAssignedProjects(<any>response_);
                } catch (e) {
                    return <Observable<ProjectSummaryModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectSummaryModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetUserAssignedProjects(response: Response): Observable<ProjectSummaryModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProjectSummaryModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectSummaryModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    accessibleProjects(): Observable<ProjectSummaryModel[]> {
        let url_ = this.baseUrl + "/users/accessible-projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAccessibleProjects(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAccessibleProjects(<any>response_);
                } catch (e) {
                    return <Observable<ProjectSummaryModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ProjectSummaryModel[]>><any>Observable.throw(response_);
        });
    }

    protected processAccessibleProjects(response: Response): Observable<ProjectSummaryModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ProjectSummaryModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ProjectSummaryModel[]>(<any>null);
    }

    /**
     * @loginRequestModel (optional) 
     * @return Success
     */
    login(loginRequestModel: LoginRequestModel): Observable<TokenResponse> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginRequestModel);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<TokenResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<TokenResponse>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: Response): Observable<TokenResponse> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TokenResponse.fromJS(resultData200) : new TokenResponse();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TokenResponse>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    activation(request: ActivateAccountRequestModel): Observable<void> {
        let url_ = this.baseUrl + "/users/activation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processActivation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processActivation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processActivation(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    resetPasswordEmail(email: string): Observable<void> {
        let url_ = this.baseUrl + "/users/reset-password-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetPasswordEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetPasswordEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetPasswordEmail(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    changePasswordEmail(email: string): Observable<void> {
        let url_ = this.baseUrl + "/users/change-password-email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangePasswordEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangePasswordEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangePasswordEmail(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @request (optional) 
     * @return Success
     */
    resetPassword(request: ResetPasswordRequestModel): Observable<void> {
        let url_ = this.baseUrl + "/users/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

export class DefectCategoryDto implements IDefectCategoryDto {
    id: number;
    name: string;
    localName: string;
    remark: string;
    type: string;

    constructor(data?: IDefectCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.localName = data["localName"];
            this.remark = data["remark"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): DefectCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefectCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["localName"] = this.localName;
        data["remark"] = this.remark;
        data["type"] = this.type;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IDefectCategoryDto {
    id: number;
    name: string;
    localName: string;
    remark: string;
    type: string;
}

export class HelpdeskConfigModel implements IHelpdeskConfigModel {
    email: string;
    phoneNumber: string;

    constructor(data?: IHelpdeskConfigModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): HelpdeskConfigModel {
        data = typeof data === 'object' ? data : {};
        let result = new HelpdeskConfigModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HelpdeskConfigModel();
        result.init(json);
        return result;
    }
}

export interface IHelpdeskConfigModel {
    email: string;
    phoneNumber: string;
}

export class HelpdeskIssueCategoryModel implements IHelpdeskIssueCategoryModel {
    id: number;
    name: string;
    displayName: string;
    localName: string;
    remark: string;
    indexTitle: string;

    constructor(data?: IHelpdeskIssueCategoryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.localName = data["localName"];
            this.remark = data["remark"];
            this.indexTitle = data["indexTitle"];
        }
    }

    static fromJS(data: any): HelpdeskIssueCategoryModel {
        data = typeof data === 'object' ? data : {};
        let result = new HelpdeskIssueCategoryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["localName"] = this.localName;
        data["remark"] = this.remark;
        data["indexTitle"] = this.indexTitle;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HelpdeskIssueCategoryModel();
        result.init(json);
        return result;
    }
}

export interface IHelpdeskIssueCategoryModel {
    id: number;
    name: string;
    displayName: string;
    localName: string;
    remark: string;
    indexTitle: string;
}

export class HelpdeskIssueModel implements IHelpdeskIssueModel {
    category: string;
    description: string;
    pictures: AttachmentModel[];
    name: string;
    email: string;
    phoneNumber: string;
    byEmailOrPhone: boolean;

    constructor(data?: IHelpdeskIssueModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.category = data["category"];
            this.description = data["description"];
            if (data["pictures"] && data["pictures"].constructor === Array) {
                this.pictures = [];
                for (let item of data["pictures"])
                    this.pictures.push(AttachmentModel.fromJS(item));
            }
            this.name = data["name"];
            this.email = data["email"];
            this.phoneNumber = data["phoneNumber"];
            this.byEmailOrPhone = data["byEmailOrPhone"];
        }
    }

    static fromJS(data: any): HelpdeskIssueModel {
        data = typeof data === 'object' ? data : {};
        let result = new HelpdeskIssueModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["description"] = this.description;
        if (this.pictures && this.pictures.constructor === Array) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["byEmailOrPhone"] = this.byEmailOrPhone;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new HelpdeskIssueModel();
        result.init(json);
        return result;
    }
}

export interface IHelpdeskIssueModel {
    category: string;
    description: string;
    pictures: AttachmentModel[];
    name: string;
    email: string;
    phoneNumber: string;
    byEmailOrPhone: boolean;
}

export class AttachmentModel implements IAttachmentModel {
    id: string;
    name: string;
    fileType: string;
    content: string;
    downloadUrl: string;
    thumbnailUrl: string;
    date: string;

    constructor(data?: IAttachmentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.fileType = data["fileType"];
            this.content = data["content"];
            this.downloadUrl = data["downloadUrl"];
            this.thumbnailUrl = data["thumbnailUrl"];
            this.date = data["date"];
        }
    }

    static fromJS(data: any): AttachmentModel {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["fileType"] = this.fileType;
        data["content"] = this.content;
        data["downloadUrl"] = this.downloadUrl;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["date"] = this.date;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AttachmentModel();
        result.init(json);
        return result;
    }
}

export interface IAttachmentModel {
    id: string;
    name: string;
    fileType: string;
    content: string;
    downloadUrl: string;
    thumbnailUrl: string;
    date: string;
}

export class ProjectPartnerDto implements IProjectPartnerDto {
    id: number;
    name: string;
    remark: string;
    type: string;

    constructor(data?: IProjectPartnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.remark = data["remark"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): ProjectPartnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPartnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["remark"] = this.remark;
        data["type"] = this.type;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectPartnerDto();
        result.init(json);
        return result;
    }
}

export interface IProjectPartnerDto {
    id: number;
    name: string;
    remark: string;
    type: string;
}

export class TotalPendingDefectStatisticDto implements ITotalPendingDefectStatisticDto {
    weekDayName: string;
    totalDefectsCount: number;
    pendingDefectsCount: number;

    constructor(data?: ITotalPendingDefectStatisticDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.weekDayName = data["weekDayName"];
            this.totalDefectsCount = data["totalDefectsCount"];
            this.pendingDefectsCount = data["pendingDefectsCount"];
        }
    }

    static fromJS(data: any): TotalPendingDefectStatisticDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalPendingDefectStatisticDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekDayName"] = this.weekDayName;
        data["totalDefectsCount"] = this.totalDefectsCount;
        data["pendingDefectsCount"] = this.pendingDefectsCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TotalPendingDefectStatisticDto();
        result.init(json);
        return result;
    }
}

export interface ITotalPendingDefectStatisticDto {
    weekDayName: string;
    totalDefectsCount: number;
    pendingDefectsCount: number;
}

export class PartnerReportStatisticDto implements IPartnerReportStatisticDto {
    projectId: number;
    companyName: string;
    totalCustomerDefectsCount: number;
    totalUnitsCount: number;
    percent: number;
    totalCount: number;

    constructor(data?: IPartnerReportStatisticDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.companyName = data["companyName"];
            this.totalCustomerDefectsCount = data["totalCustomerDefectsCount"];
            this.totalUnitsCount = data["totalUnitsCount"];
            this.percent = data["percent"];
            this.totalCount = data["totalCount"];
        }
    }

    static fromJS(data: any): PartnerReportStatisticDto {
        data = typeof data === 'object' ? data : {};
        let result = new PartnerReportStatisticDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["companyName"] = this.companyName;
        data["totalCustomerDefectsCount"] = this.totalCustomerDefectsCount;
        data["totalUnitsCount"] = this.totalUnitsCount;
        data["percent"] = this.percent;
        data["totalCount"] = this.totalCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PartnerReportStatisticDto();
        result.init(json);
        return result;
    }
}

export interface IPartnerReportStatisticDto {
    projectId: number;
    companyName: string;
    totalCustomerDefectsCount: number;
    totalUnitsCount: number;
    percent: number;
    totalCount: number;
}

export class UnitStatusStatisticDto implements IUnitStatusStatisticDto {
    asisNameX: string;
    monthName: string;
    projectName: string;
    notCompleteCount: number;
    roomFinishedCount: number;
    cmDefectCount: number;
    readyFormPMCCheckCount: number;
    pmcDefectCount: number;
    readyForCustomerCheckCount: number;
    customerDefectCount: number;
    buDefectCount: number;
    correctionCompleteCount: number;
    customerAcceptedCount: number;
    readyForCustomerCheckUnsoldCount: number;
    totalUnitsCount: number;
    totalTransferedCount: number;

    constructor(data?: IUnitStatusStatisticDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.asisNameX = data["asisNameX"];
            this.monthName = data["monthName"];
            this.projectName = data["projectName"];
            this.notCompleteCount = data["notCompleteCount"];
            this.roomFinishedCount = data["roomFinishedCount"];
            this.cmDefectCount = data["cmDefectCount"];
            this.readyFormPMCCheckCount = data["readyFormPMCCheckCount"];
            this.pmcDefectCount = data["pmcDefectCount"];
            this.readyForCustomerCheckCount = data["readyForCustomerCheckCount"];
            this.customerDefectCount = data["customerDefectCount"];
            this.buDefectCount = data["buDefectCount"];
            this.correctionCompleteCount = data["correctionCompleteCount"];
            this.customerAcceptedCount = data["customerAcceptedCount"];
            this.readyForCustomerCheckUnsoldCount = data["readyForCustomerCheckUnsoldCount"];
            this.totalUnitsCount = data["totalUnitsCount"];
            this.totalTransferedCount = data["totalTransferedCount"];
        }
    }

    static fromJS(data: any): UnitStatusStatisticDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitStatusStatisticDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asisNameX"] = this.asisNameX;
        data["monthName"] = this.monthName;
        data["projectName"] = this.projectName;
        data["notCompleteCount"] = this.notCompleteCount;
        data["roomFinishedCount"] = this.roomFinishedCount;
        data["cmDefectCount"] = this.cmDefectCount;
        data["readyFormPMCCheckCount"] = this.readyFormPMCCheckCount;
        data["pmcDefectCount"] = this.pmcDefectCount;
        data["readyForCustomerCheckCount"] = this.readyForCustomerCheckCount;
        data["customerDefectCount"] = this.customerDefectCount;
        data["buDefectCount"] = this.buDefectCount;
        data["correctionCompleteCount"] = this.correctionCompleteCount;
        data["customerAcceptedCount"] = this.customerAcceptedCount;
        data["readyForCustomerCheckUnsoldCount"] = this.readyForCustomerCheckUnsoldCount;
        data["totalUnitsCount"] = this.totalUnitsCount;
        data["totalTransferedCount"] = this.totalTransferedCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitStatusStatisticDto();
        result.init(json);
        return result;
    }
}

export interface IUnitStatusStatisticDto {
    asisNameX: string;
    monthName: string;
    projectName: string;
    notCompleteCount: number;
    roomFinishedCount: number;
    cmDefectCount: number;
    readyFormPMCCheckCount: number;
    pmcDefectCount: number;
    readyForCustomerCheckCount: number;
    customerDefectCount: number;
    buDefectCount: number;
    correctionCompleteCount: number;
    customerAcceptedCount: number;
    readyForCustomerCheckUnsoldCount: number;
    totalUnitsCount: number;
    totalTransferedCount: number;
}

export class UnitTransferredDto implements IUnitTransferredDto {
    projectName: string;
    totalUnitCount: number;
    transferredCount: number;
    percentage: number;

    constructor(data?: IUnitTransferredDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectName = data["projectName"];
            this.totalUnitCount = data["totalUnitCount"];
            this.transferredCount = data["transferredCount"];
            this.percentage = data["percentage"];
        }
    }

    static fromJS(data: any): UnitTransferredDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitTransferredDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        data["totalUnitCount"] = this.totalUnitCount;
        data["transferredCount"] = this.transferredCount;
        data["percentage"] = this.percentage;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitTransferredDto();
        result.init(json);
        return result;
    }
}

export interface IUnitTransferredDto {
    projectName: string;
    totalUnitCount: number;
    transferredCount: number;
    percentage: number;
}

export class AvgDefectsPerUnitStatisticDto implements IAvgDefectsPerUnitStatisticDto {
    projectName: string;
    averageDefectCount: number;

    constructor(data?: IAvgDefectsPerUnitStatisticDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectName = data["projectName"];
            this.averageDefectCount = data["averageDefectCount"];
        }
    }

    static fromJS(data: any): AvgDefectsPerUnitStatisticDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvgDefectsPerUnitStatisticDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        data["averageDefectCount"] = this.averageDefectCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AvgDefectsPerUnitStatisticDto();
        result.init(json);
        return result;
    }
}

export interface IAvgDefectsPerUnitStatisticDto {
    projectName: string;
    averageDefectCount: number;
}

export class TopCSModel implements ITopCSModel {
    id: string;
    index: number;
    name: string;
    realName: string;
    count: number;
    titleColor: string;
    color: string;
    type: string;
    indexIcon: string;

    constructor(data?: ITopCSModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.index = data["index"];
            this.name = data["name"];
            this.realName = data["realName"];
            this.count = data["count"];
            this.titleColor = data["titleColor"];
            this.color = data["color"];
            this.type = data["type"];
            this.indexIcon = data["indexIcon"];
        }
    }

    static fromJS(data: any): TopCSModel {
        data = typeof data === 'object' ? data : {};
        let result = new TopCSModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["name"] = this.name;
        data["realName"] = this.realName;
        data["count"] = this.count;
        data["titleColor"] = this.titleColor;
        data["color"] = this.color;
        data["type"] = this.type;
        data["indexIcon"] = this.indexIcon;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TopCSModel();
        result.init(json);
        return result;
    }
}

export interface ITopCSModel {
    id: string;
    index: number;
    name: string;
    realName: string;
    count: number;
    titleColor: string;
    color: string;
    type: string;
    indexIcon: string;
}

export class DefectStatisticModel implements IDefectStatisticModel {
    key: string;
    value: string;
    count: number;
    percentage: string;
    color: string;
    type: string;
    time: string;

    constructor(data?: IDefectStatisticModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.value = data["value"];
            this.count = data["count"];
            this.percentage = data["percentage"];
            this.color = data["color"];
            this.type = data["type"];
            this.time = data["time"];
        }
    }

    static fromJS(data: any): DefectStatisticModel {
        data = typeof data === 'object' ? data : {};
        let result = new DefectStatisticModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        data["color"] = this.color;
        data["type"] = this.type;
        data["time"] = this.time;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectStatisticModel();
        result.init(json);
        return result;
    }
}

export interface IDefectStatisticModel {
    key: string;
    value: string;
    count: number;
    percentage: string;
    color: string;
    type: string;
    time: string;
}

export class ProjectSearchDto implements IProjectSearchDto {
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IProjectSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectSearchDto();
        result.init(json);
        return result;
    }
}

export interface IProjectSearchDto {
    skipCount: number;
    maxResultCount: number;
}

export class PagedResultDtoOfProjectSummaryDto implements IPagedResultDtoOfProjectSummaryDto {
    totalCount: number;
    items: ProjectSummaryDto[];

    constructor(data?: IPagedResultDtoOfProjectSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProjectSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfProjectSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfProjectSummaryDto {
    totalCount: number;
    items: ProjectSummaryDto[];
}

export class ProjectSummaryDto implements IProjectSummaryDto {
    id: number;
    name: string;
    brandName: string;
    imageUrl: string;
    projectNo: string;
    numberOfUnits: number;
    numberOfDefects: number;
    numberOfFloors: number;
    cmCompanies: ProjectPartnerDto[];
    contractorCompanies: ProjectPartnerDto[];
    printers: PrinterDto[];

    constructor(data?: IProjectSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.brandName = data["brandName"];
            this.imageUrl = data["imageUrl"];
            this.projectNo = data["projectNo"];
            this.numberOfUnits = data["numberOfUnits"];
            this.numberOfDefects = data["numberOfDefects"];
            this.numberOfFloors = data["numberOfFloors"];
            if (data["cmCompanies"] && data["cmCompanies"].constructor === Array) {
                this.cmCompanies = [];
                for (let item of data["cmCompanies"])
                    this.cmCompanies.push(ProjectPartnerDto.fromJS(item));
            }
            if (data["contractorCompanies"] && data["contractorCompanies"].constructor === Array) {
                this.contractorCompanies = [];
                for (let item of data["contractorCompanies"])
                    this.contractorCompanies.push(ProjectPartnerDto.fromJS(item));
            }
            if (data["printers"] && data["printers"].constructor === Array) {
                this.printers = [];
                for (let item of data["printers"])
                    this.printers.push(PrinterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["brandName"] = this.brandName;
        data["imageUrl"] = this.imageUrl;
        data["projectNo"] = this.projectNo;
        data["numberOfUnits"] = this.numberOfUnits;
        data["numberOfDefects"] = this.numberOfDefects;
        data["numberOfFloors"] = this.numberOfFloors;
        if (this.cmCompanies && this.cmCompanies.constructor === Array) {
            data["cmCompanies"] = [];
            for (let item of this.cmCompanies)
                data["cmCompanies"].push(item.toJSON());
        }
        if (this.contractorCompanies && this.contractorCompanies.constructor === Array) {
            data["contractorCompanies"] = [];
            for (let item of this.contractorCompanies)
                data["contractorCompanies"].push(item.toJSON());
        }
        if (this.printers && this.printers.constructor === Array) {
            data["printers"] = [];
            for (let item of this.printers)
                data["printers"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IProjectSummaryDto {
    id: number;
    name: string;
    brandName: string;
    imageUrl: string;
    projectNo: string;
    numberOfUnits: number;
    numberOfDefects: number;
    numberOfFloors: number;
    cmCompanies: ProjectPartnerDto[];
    contractorCompanies: ProjectPartnerDto[];
    printers: PrinterDto[];
}

export class PrinterDto implements IPrinterDto {
    id: string;
    name: string;

    constructor(data?: IPrinterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PrinterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrinterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PrinterDto();
        result.init(json);
        return result;
    }
}

export interface IPrinterDto {
    id: string;
    name: string;
}

export class ProjectDetailDto implements IProjectDetailDto {
    projectSummaryInfo: ProjectSummaryDto;
    assignedStaffs: StaffDto[];
    buildings: BuildingDto[];
    deletedBuildingIds: number[];
    deletedRoomTypeIds: number[];
    hasDefect: boolean;

    constructor(data?: IProjectDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectSummaryInfo = data["projectSummaryInfo"] ? ProjectSummaryDto.fromJS(data["projectSummaryInfo"]) : <any>undefined;
            if (data["assignedStaffs"] && data["assignedStaffs"].constructor === Array) {
                this.assignedStaffs = [];
                for (let item of data["assignedStaffs"])
                    this.assignedStaffs.push(StaffDto.fromJS(item));
            }
            if (data["buildings"] && data["buildings"].constructor === Array) {
                this.buildings = [];
                for (let item of data["buildings"])
                    this.buildings.push(BuildingDto.fromJS(item));
            }
            if (data["deletedBuildingIds"] && data["deletedBuildingIds"].constructor === Array) {
                this.deletedBuildingIds = [];
                for (let item of data["deletedBuildingIds"])
                    this.deletedBuildingIds.push(item);
            }
            if (data["deletedRoomTypeIds"] && data["deletedRoomTypeIds"].constructor === Array) {
                this.deletedRoomTypeIds = [];
                for (let item of data["deletedRoomTypeIds"])
                    this.deletedRoomTypeIds.push(item);
            }
            this.hasDefect = data["hasDefect"];
        }
    }

    static fromJS(data: any): ProjectDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectSummaryInfo"] = this.projectSummaryInfo ? this.projectSummaryInfo.toJSON() : <any>undefined;
        if (this.assignedStaffs && this.assignedStaffs.constructor === Array) {
            data["assignedStaffs"] = [];
            for (let item of this.assignedStaffs)
                data["assignedStaffs"].push(item.toJSON());
        }
        if (this.buildings && this.buildings.constructor === Array) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        if (this.deletedBuildingIds && this.deletedBuildingIds.constructor === Array) {
            data["deletedBuildingIds"] = [];
            for (let item of this.deletedBuildingIds)
                data["deletedBuildingIds"].push(item);
        }
        if (this.deletedRoomTypeIds && this.deletedRoomTypeIds.constructor === Array) {
            data["deletedRoomTypeIds"] = [];
            for (let item of this.deletedRoomTypeIds)
                data["deletedRoomTypeIds"].push(item);
        }
        data["hasDefect"] = this.hasDefect;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectDetailDto();
        result.init(json);
        return result;
    }
}

export interface IProjectDetailDto {
    projectSummaryInfo: ProjectSummaryDto;
    assignedStaffs: StaffDto[];
    buildings: BuildingDto[];
    deletedBuildingIds: number[];
    deletedRoomTypeIds: number[];
    hasDefect: boolean;
}

export class StaffDto implements IStaffDto {
    id: number;
    name: string;
    role: string;

    constructor(data?: IStaffDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): StaffDto {
        data = typeof data === 'object' ? data : {};
        let result = new StaffDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["role"] = this.role;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new StaffDto();
        result.init(json);
        return result;
    }
}

export interface IStaffDto {
    id: number;
    name: string;
    role: string;
}

export class BuildingDto implements IBuildingDto {
    id: number;
    name: string;
    defectsCount: number;
    pojectHasDefect: boolean;
    roomTypes: RoomTypeDto[];

    constructor(data?: IBuildingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.defectsCount = data["defectsCount"];
            this.pojectHasDefect = data["pojectHasDefect"];
            if (data["roomTypes"] && data["roomTypes"].constructor === Array) {
                this.roomTypes = [];
                for (let item of data["roomTypes"])
                    this.roomTypes.push(RoomTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BuildingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["defectsCount"] = this.defectsCount;
        data["pojectHasDefect"] = this.pojectHasDefect;
        if (this.roomTypes && this.roomTypes.constructor === Array) {
            data["roomTypes"] = [];
            for (let item of this.roomTypes)
                data["roomTypes"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BuildingDto();
        result.init(json);
        return result;
    }
}

export interface IBuildingDto {
    id: number;
    name: string;
    defectsCount: number;
    pojectHasDefect: boolean;
    roomTypes: RoomTypeDto[];
}

export class RoomTypeDto implements IRoomTypeDto {
    id: number;
    type: string;
    area: number;
    roomAreas: DefectCategoryDto[];
    floorPlanImageUrls: string[];
    floorPlanImages: string[];

    constructor(data?: IRoomTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.type = data["type"];
            this.area = data["area"];
            if (data["roomAreas"] && data["roomAreas"].constructor === Array) {
                this.roomAreas = [];
                for (let item of data["roomAreas"])
                    this.roomAreas.push(DefectCategoryDto.fromJS(item));
            }
            if (data["floorPlanImageUrls"] && data["floorPlanImageUrls"].constructor === Array) {
                this.floorPlanImageUrls = [];
                for (let item of data["floorPlanImageUrls"])
                    this.floorPlanImageUrls.push(item);
            }
            if (data["floorPlanImages"] && data["floorPlanImages"].constructor === Array) {
                this.floorPlanImages = [];
                for (let item of data["floorPlanImages"])
                    this.floorPlanImages.push(item);
            }
        }
    }

    static fromJS(data: any): RoomTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["area"] = this.area;
        if (this.roomAreas && this.roomAreas.constructor === Array) {
            data["roomAreas"] = [];
            for (let item of this.roomAreas)
                data["roomAreas"].push(item.toJSON());
        }
        if (this.floorPlanImageUrls && this.floorPlanImageUrls.constructor === Array) {
            data["floorPlanImageUrls"] = [];
            for (let item of this.floorPlanImageUrls)
                data["floorPlanImageUrls"].push(item);
        }
        if (this.floorPlanImages && this.floorPlanImages.constructor === Array) {
            data["floorPlanImages"] = [];
            for (let item of this.floorPlanImages)
                data["floorPlanImages"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoomTypeDto();
        result.init(json);
        return result;
    }
}

export interface IRoomTypeDto {
    id: number;
    type: string;
    area: number;
    roomAreas: DefectCategoryDto[];
    floorPlanImageUrls: string[];
    floorPlanImages: string[];
}

export class ErrorDto implements IErrorDto {
    errorCategory: string;
    errorMessage: string;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorCategory = data["errorCategory"];
            this.errorMessage = data["errorMessage"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCategory"] = this.errorCategory;
        data["errorMessage"] = this.errorMessage;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ErrorDto();
        result.init(json);
        return result;
    }
}

export interface IErrorDto {
    errorCategory: string;
    errorMessage: string;
}

export class ProjectLayoutSearchDto implements IProjectLayoutSearchDto {
    projectId: number;
    building: string;
    floor: string;
    unit: string;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IProjectLayoutSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.building = data["building"];
            this.floor = data["floor"];
            this.unit = data["unit"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectLayoutSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLayoutSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["building"] = this.building;
        data["floor"] = this.floor;
        data["unit"] = this.unit;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectLayoutSearchDto();
        result.init(json);
        return result;
    }
}

export interface IProjectLayoutSearchDto {
    projectId: number;
    building: string;
    floor: string;
    unit: string;
    skipCount: number;
    maxResultCount: number;
}

export class PagedResultDtoOfProjectLayoutDto implements IPagedResultDtoOfProjectLayoutDto {
    totalCount: number;
    items: ProjectLayoutDto[];

    constructor(data?: IPagedResultDtoOfProjectLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ProjectLayoutDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfProjectLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfProjectLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfProjectLayoutDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfProjectLayoutDto {
    totalCount: number;
    items: ProjectLayoutDto[];
}

export class ProjectLayoutDto implements IProjectLayoutDto {
    building: string;
    floorNo: string;
    unitNo: string;
    unitName: string;
    roomType: string;
    unitStatus: string;

    constructor(data?: IProjectLayoutDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"];
            this.floorNo = data["floorNo"];
            this.unitNo = data["unitNo"];
            this.unitName = data["unitName"];
            this.roomType = data["roomType"];
            this.unitStatus = data["unitStatus"];
        }
    }

    static fromJS(data: any): ProjectLayoutDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLayoutDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building;
        data["floorNo"] = this.floorNo;
        data["unitNo"] = this.unitNo;
        data["unitName"] = this.unitName;
        data["roomType"] = this.roomType;
        data["unitStatus"] = this.unitStatus;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectLayoutDto();
        result.init(json);
        return result;
    }
}

export interface IProjectLayoutDto {
    building: string;
    floorNo: string;
    unitNo: string;
    unitName: string;
    roomType: string;
    unitStatus: string;
}

export class ImportLayoutErrorResponse implements IImportLayoutErrorResponse {
    building: string;
    isBuildingError: boolean;
    floorNo: string;
    isFloorNoError: boolean;
    unitNo: string;
    isUnitNoError: boolean;
    roomType: string;
    isRoomTypeError: boolean;
    unitStatus: string;
    isUnitStatusError: boolean;
    isDuplicate: boolean;

    constructor(data?: IImportLayoutErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"];
            this.isBuildingError = data["isBuildingError"];
            this.floorNo = data["floorNo"];
            this.isFloorNoError = data["isFloorNoError"];
            this.unitNo = data["unitNo"];
            this.isUnitNoError = data["isUnitNoError"];
            this.roomType = data["roomType"];
            this.isRoomTypeError = data["isRoomTypeError"];
            this.unitStatus = data["unitStatus"];
            this.isUnitStatusError = data["isUnitStatusError"];
            this.isDuplicate = data["isDuplicate"];
        }
    }

    static fromJS(data: any): ImportLayoutErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ImportLayoutErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building;
        data["isBuildingError"] = this.isBuildingError;
        data["floorNo"] = this.floorNo;
        data["isFloorNoError"] = this.isFloorNoError;
        data["unitNo"] = this.unitNo;
        data["isUnitNoError"] = this.isUnitNoError;
        data["roomType"] = this.roomType;
        data["isRoomTypeError"] = this.isRoomTypeError;
        data["unitStatus"] = this.unitStatus;
        data["isUnitStatusError"] = this.isUnitStatusError;
        data["isDuplicate"] = this.isDuplicate;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ImportLayoutErrorResponse();
        result.init(json);
        return result;
    }
}

export interface IImportLayoutErrorResponse {
    building: string;
    isBuildingError: boolean;
    floorNo: string;
    isFloorNoError: boolean;
    unitNo: string;
    isUnitNoError: boolean;
    roomType: string;
    isRoomTypeError: boolean;
    unitStatus: string;
    isUnitStatusError: boolean;
    isDuplicate: boolean;
}

export class ExportUrlDto implements IExportUrlDto {
    reportUrl: string;

    constructor(data?: IExportUrlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reportUrl = data["reportUrl"];
        }
    }

    static fromJS(data: any): ExportUrlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExportUrlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportUrl"] = this.reportUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExportUrlDto();
        result.init(json);
        return result;
    }
}

export interface IExportUrlDto {
    reportUrl: string;
}

export class ProjectBuildingStatusReportDto implements IProjectBuildingStatusReportDto {
    floorStatusList: FloorStatustDto[];
    fullUnitNames: string[];
    roomCount: number;
    floorCount: number;
    currentBuildingName: string;
    projectName: string;
    units: UnitExportModel[];
    preCustomerSummary: UnitStatusModel[];
    postCustomerSummary: UnitStatusModel[];
    lastUpdatedTime: string;
    preCustomerInspectionTotal: number;
    postCustomerInspectionTotal: number;
    grandTotal: number;

    constructor(data?: IProjectBuildingStatusReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["floorStatusList"] && data["floorStatusList"].constructor === Array) {
                this.floorStatusList = [];
                for (let item of data["floorStatusList"])
                    this.floorStatusList.push(FloorStatustDto.fromJS(item));
            }
            if (data["fullUnitNames"] && data["fullUnitNames"].constructor === Array) {
                this.fullUnitNames = [];
                for (let item of data["fullUnitNames"])
                    this.fullUnitNames.push(item);
            }
            this.roomCount = data["roomCount"];
            this.floorCount = data["floorCount"];
            this.currentBuildingName = data["currentBuildingName"];
            this.projectName = data["projectName"];
            if (data["units"] && data["units"].constructor === Array) {
                this.units = [];
                for (let item of data["units"])
                    this.units.push(UnitExportModel.fromJS(item));
            }
            if (data["preCustomerSummary"] && data["preCustomerSummary"].constructor === Array) {
                this.preCustomerSummary = [];
                for (let item of data["preCustomerSummary"])
                    this.preCustomerSummary.push(UnitStatusModel.fromJS(item));
            }
            if (data["postCustomerSummary"] && data["postCustomerSummary"].constructor === Array) {
                this.postCustomerSummary = [];
                for (let item of data["postCustomerSummary"])
                    this.postCustomerSummary.push(UnitStatusModel.fromJS(item));
            }
            this.lastUpdatedTime = data["lastUpdatedTime"];
            this.preCustomerInspectionTotal = data["preCustomerInspectionTotal"];
            this.postCustomerInspectionTotal = data["postCustomerInspectionTotal"];
            this.grandTotal = data["grandTotal"];
        }
    }

    static fromJS(data: any): ProjectBuildingStatusReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBuildingStatusReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.floorStatusList && this.floorStatusList.constructor === Array) {
            data["floorStatusList"] = [];
            for (let item of this.floorStatusList)
                data["floorStatusList"].push(item.toJSON());
        }
        if (this.fullUnitNames && this.fullUnitNames.constructor === Array) {
            data["fullUnitNames"] = [];
            for (let item of this.fullUnitNames)
                data["fullUnitNames"].push(item);
        }
        data["roomCount"] = this.roomCount;
        data["floorCount"] = this.floorCount;
        data["currentBuildingName"] = this.currentBuildingName;
        data["projectName"] = this.projectName;
        if (this.units && this.units.constructor === Array) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        if (this.preCustomerSummary && this.preCustomerSummary.constructor === Array) {
            data["preCustomerSummary"] = [];
            for (let item of this.preCustomerSummary)
                data["preCustomerSummary"].push(item.toJSON());
        }
        if (this.postCustomerSummary && this.postCustomerSummary.constructor === Array) {
            data["postCustomerSummary"] = [];
            for (let item of this.postCustomerSummary)
                data["postCustomerSummary"].push(item.toJSON());
        }
        data["lastUpdatedTime"] = this.lastUpdatedTime;
        data["preCustomerInspectionTotal"] = this.preCustomerInspectionTotal;
        data["postCustomerInspectionTotal"] = this.postCustomerInspectionTotal;
        data["grandTotal"] = this.grandTotal;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectBuildingStatusReportDto();
        result.init(json);
        return result;
    }
}

export interface IProjectBuildingStatusReportDto {
    floorStatusList: FloorStatustDto[];
    fullUnitNames: string[];
    roomCount: number;
    floorCount: number;
    currentBuildingName: string;
    projectName: string;
    units: UnitExportModel[];
    preCustomerSummary: UnitStatusModel[];
    postCustomerSummary: UnitStatusModel[];
    lastUpdatedTime: string;
    preCustomerInspectionTotal: number;
    postCustomerInspectionTotal: number;
    grandTotal: number;
}

export class FloorStatustDto implements IFloorStatustDto {
    floorName: string;
    floorNo: string;
    unitStatusList: UnitStatusDto[];

    constructor(data?: IFloorStatustDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.floorName = data["floorName"];
            this.floorNo = data["floorNo"];
            if (data["unitStatusList"] && data["unitStatusList"].constructor === Array) {
                this.unitStatusList = [];
                for (let item of data["unitStatusList"])
                    this.unitStatusList.push(UnitStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FloorStatustDto {
        data = typeof data === 'object' ? data : {};
        let result = new FloorStatustDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["floorName"] = this.floorName;
        data["floorNo"] = this.floorNo;
        if (this.unitStatusList && this.unitStatusList.constructor === Array) {
            data["unitStatusList"] = [];
            for (let item of this.unitStatusList)
                data["unitStatusList"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FloorStatustDto();
        result.init(json);
        return result;
    }
}

export interface IFloorStatustDto {
    floorName: string;
    floorNo: string;
    unitStatusList: UnitStatusDto[];
}

export class UnitExportModel implements IUnitExportModel {
    startUnitNumber: number;
    statusCode: string;
    statusCodeColor: string;
    floor: string;
    floorOrder: number;
    lastUpdatedTime: number;
    isPublicFacility: boolean;
    unitAmount: number;
    unitName: string;

    constructor(data?: IUnitExportModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startUnitNumber = data["startUnitNumber"];
            this.statusCode = data["statusCode"];
            this.statusCodeColor = data["statusCodeColor"];
            this.floor = data["floor"];
            this.floorOrder = data["floorOrder"];
            this.lastUpdatedTime = data["lastUpdatedTime"];
            this.isPublicFacility = data["isPublicFacility"];
            this.unitAmount = data["unitAmount"];
            this.unitName = data["unitName"];
        }
    }

    static fromJS(data: any): UnitExportModel {
        data = typeof data === 'object' ? data : {};
        let result = new UnitExportModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startUnitNumber"] = this.startUnitNumber;
        data["statusCode"] = this.statusCode;
        data["statusCodeColor"] = this.statusCodeColor;
        data["floor"] = this.floor;
        data["floorOrder"] = this.floorOrder;
        data["lastUpdatedTime"] = this.lastUpdatedTime;
        data["isPublicFacility"] = this.isPublicFacility;
        data["unitAmount"] = this.unitAmount;
        data["unitName"] = this.unitName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitExportModel();
        result.init(json);
        return result;
    }
}

export interface IUnitExportModel {
    startUnitNumber: number;
    statusCode: string;
    statusCodeColor: string;
    floor: string;
    floorOrder: number;
    lastUpdatedTime: number;
    isPublicFacility: boolean;
    unitAmount: number;
    unitName: string;
}

export class UnitStatusModel implements IUnitStatusModel {
    unitStatusName: string;
    unitStatusCode: string;
    count: number;
    percentage: string;
    color: string;
    type: string;

    constructor(data?: IUnitStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitStatusName = data["unitStatusName"];
            this.unitStatusCode = data["unitStatusCode"];
            this.count = data["count"];
            this.percentage = data["percentage"];
            this.color = data["color"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): UnitStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new UnitStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitStatusName"] = this.unitStatusName;
        data["unitStatusCode"] = this.unitStatusCode;
        data["count"] = this.count;
        data["percentage"] = this.percentage;
        data["color"] = this.color;
        data["type"] = this.type;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitStatusModel();
        result.init(json);
        return result;
    }
}

export interface IUnitStatusModel {
    unitStatusName: string;
    unitStatusCode: string;
    count: number;
    percentage: string;
    color: string;
    type: string;
}

export class UnitStatusDto implements IUnitStatusDto {
    statusCode: string;
    statusCodeColor: string;
    unitName: string;
    isEmpty: boolean;

    constructor(data?: IUnitStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statusCode = data["statusCode"];
            this.statusCodeColor = data["statusCodeColor"];
            this.unitName = data["unitName"];
            this.isEmpty = data["isEmpty"];
        }
    }

    static fromJS(data: any): UnitStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnitStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["statusCodeColor"] = this.statusCodeColor;
        data["unitName"] = this.unitName;
        data["isEmpty"] = this.isEmpty;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitStatusDto();
        result.init(json);
        return result;
    }
}

export interface IUnitStatusDto {
    statusCode: string;
    statusCodeColor: string;
    unitName: string;
    isEmpty: boolean;
}

export class ProjectDefectsSearchDto implements IProjectDefectsSearchDto {
    projectId: number;
    buildingId: string;
    floorNum: string;
    statusCode: string;
    reporterRole: string;
    area: string;
    component: string;
    keyWords: string;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IProjectDefectsSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.buildingId = data["buildingId"];
            this.floorNum = data["floorNum"];
            this.statusCode = data["statusCode"];
            this.reporterRole = data["reporterRole"];
            this.area = data["area"];
            this.component = data["component"];
            this.keyWords = data["keyWords"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): ProjectDefectsSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDefectsSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["buildingId"] = this.buildingId;
        data["floorNum"] = this.floorNum;
        data["statusCode"] = this.statusCode;
        data["reporterRole"] = this.reporterRole;
        data["area"] = this.area;
        data["component"] = this.component;
        data["keyWords"] = this.keyWords;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectDefectsSearchDto();
        result.init(json);
        return result;
    }
}

export interface IProjectDefectsSearchDto {
    projectId: number;
    buildingId: string;
    floorNum: string;
    statusCode: string;
    reporterRole: string;
    area: string;
    component: string;
    keyWords: string;
    skipCount: number;
    maxResultCount: number;
}

export class PagedResultDtoOfDefectSummaryDto implements IPagedResultDtoOfDefectSummaryDto {
    totalCount: number;
    items: DefectSummaryDto[];

    constructor(data?: IPagedResultDtoOfDefectSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DefectSummaryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDefectSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDefectSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDefectSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDefectSummaryDto {
    totalCount: number;
    items: DefectSummaryDto[];
}

export class DefectSummaryDto implements IDefectSummaryDto {
    id: string;
    building: string;
    floorNo: string;
    unitNo: string;
    defectId: string;
    area: string;
    component: string;
    status: string;
    reporter: string;
    createdDateTime: string;
    description: string;

    constructor(data?: IDefectSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.building = data["building"];
            this.floorNo = data["floorNo"];
            this.unitNo = data["unitNo"];
            this.defectId = data["defectId"];
            this.area = data["area"];
            this.component = data["component"];
            this.status = data["status"];
            this.reporter = data["reporter"];
            this.createdDateTime = data["createdDateTime"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): DefectSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefectSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["building"] = this.building;
        data["floorNo"] = this.floorNo;
        data["unitNo"] = this.unitNo;
        data["defectId"] = this.defectId;
        data["area"] = this.area;
        data["component"] = this.component;
        data["status"] = this.status;
        data["reporter"] = this.reporter;
        data["createdDateTime"] = this.createdDateTime;
        data["description"] = this.description;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectSummaryDto();
        result.init(json);
        return result;
    }
}

export interface IDefectSummaryDto {
    id: string;
    building: string;
    floorNo: string;
    unitNo: string;
    defectId: string;
    area: string;
    component: string;
    status: string;
    reporter: string;
    createdDateTime: string;
    description: string;
}

export class GlobalSettingDto implements IGlobalSettingDto {
    printers: PrinterDto[];
    contractorCompanies: ProjectPartnerDto[];
    cmCompanies: ProjectPartnerDto[];
    roomAreas: DefectCategoryDto[];
    components: DefectCategoryDto[];
    brands: BrandDto[];
    projectNames: string[];

    constructor(data?: IGlobalSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["printers"] && data["printers"].constructor === Array) {
                this.printers = [];
                for (let item of data["printers"])
                    this.printers.push(PrinterDto.fromJS(item));
            }
            if (data["contractorCompanies"] && data["contractorCompanies"].constructor === Array) {
                this.contractorCompanies = [];
                for (let item of data["contractorCompanies"])
                    this.contractorCompanies.push(ProjectPartnerDto.fromJS(item));
            }
            if (data["cmCompanies"] && data["cmCompanies"].constructor === Array) {
                this.cmCompanies = [];
                for (let item of data["cmCompanies"])
                    this.cmCompanies.push(ProjectPartnerDto.fromJS(item));
            }
            if (data["roomAreas"] && data["roomAreas"].constructor === Array) {
                this.roomAreas = [];
                for (let item of data["roomAreas"])
                    this.roomAreas.push(DefectCategoryDto.fromJS(item));
            }
            if (data["components"] && data["components"].constructor === Array) {
                this.components = [];
                for (let item of data["components"])
                    this.components.push(DefectCategoryDto.fromJS(item));
            }
            if (data["brands"] && data["brands"].constructor === Array) {
                this.brands = [];
                for (let item of data["brands"])
                    this.brands.push(BrandDto.fromJS(item));
            }
            if (data["projectNames"] && data["projectNames"].constructor === Array) {
                this.projectNames = [];
                for (let item of data["projectNames"])
                    this.projectNames.push(item);
            }
        }
    }

    static fromJS(data: any): GlobalSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.printers && this.printers.constructor === Array) {
            data["printers"] = [];
            for (let item of this.printers)
                data["printers"].push(item.toJSON());
        }
        if (this.contractorCompanies && this.contractorCompanies.constructor === Array) {
            data["contractorCompanies"] = [];
            for (let item of this.contractorCompanies)
                data["contractorCompanies"].push(item.toJSON());
        }
        if (this.cmCompanies && this.cmCompanies.constructor === Array) {
            data["cmCompanies"] = [];
            for (let item of this.cmCompanies)
                data["cmCompanies"].push(item.toJSON());
        }
        if (this.roomAreas && this.roomAreas.constructor === Array) {
            data["roomAreas"] = [];
            for (let item of this.roomAreas)
                data["roomAreas"].push(item.toJSON());
        }
        if (this.components && this.components.constructor === Array) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        if (this.brands && this.brands.constructor === Array) {
            data["brands"] = [];
            for (let item of this.brands)
                data["brands"].push(item.toJSON());
        }
        if (this.projectNames && this.projectNames.constructor === Array) {
            data["projectNames"] = [];
            for (let item of this.projectNames)
                data["projectNames"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GlobalSettingDto();
        result.init(json);
        return result;
    }
}

export interface IGlobalSettingDto {
    printers: PrinterDto[];
    contractorCompanies: ProjectPartnerDto[];
    cmCompanies: ProjectPartnerDto[];
    roomAreas: DefectCategoryDto[];
    components: DefectCategoryDto[];
    brands: BrandDto[];
    projectNames: string[];
}

export class BrandDto implements IBrandDto {
    id: number;
    name: string;

    constructor(data?: IBrandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): BrandDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BrandDto();
        result.init(json);
        return result;
    }
}

export interface IBrandDto {
    id: number;
    name: string;
}

export class ProjectSettingDto implements IProjectSettingDto {
    projectId: number;
    buildings: BuildingDto[];
    floors: Floor[];
    areas: string[];
    components: string[];
    unitNoes: string[];

    constructor(data?: IProjectSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            if (data["buildings"] && data["buildings"].constructor === Array) {
                this.buildings = [];
                for (let item of data["buildings"])
                    this.buildings.push(BuildingDto.fromJS(item));
            }
            if (data["floors"] && data["floors"].constructor === Array) {
                this.floors = [];
                for (let item of data["floors"])
                    this.floors.push(Floor.fromJS(item));
            }
            if (data["areas"] && data["areas"].constructor === Array) {
                this.areas = [];
                for (let item of data["areas"])
                    this.areas.push(item);
            }
            if (data["components"] && data["components"].constructor === Array) {
                this.components = [];
                for (let item of data["components"])
                    this.components.push(item);
            }
            if (data["unitNoes"] && data["unitNoes"].constructor === Array) {
                this.unitNoes = [];
                for (let item of data["unitNoes"])
                    this.unitNoes.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        if (this.buildings && this.buildings.constructor === Array) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        if (this.floors && this.floors.constructor === Array) {
            data["floors"] = [];
            for (let item of this.floors)
                data["floors"].push(item.toJSON());
        }
        if (this.areas && this.areas.constructor === Array) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item);
        }
        if (this.components && this.components.constructor === Array) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item);
        }
        if (this.unitNoes && this.unitNoes.constructor === Array) {
            data["unitNoes"] = [];
            for (let item of this.unitNoes)
                data["unitNoes"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectSettingDto();
        result.init(json);
        return result;
    }
}

export interface IProjectSettingDto {
    projectId: number;
    buildings: BuildingDto[];
    floors: Floor[];
    areas: string[];
    components: string[];
    unitNoes: string[];
}

export class Floor implements IFloor {
    name: string;
    order: number;
    buildingId: string;

    constructor(data?: IFloor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.order = data["order"];
            this.buildingId = data["buildingId"];
        }
    }

    static fromJS(data: any): Floor {
        data = typeof data === 'object' ? data : {};
        let result = new Floor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        data["buildingId"] = this.buildingId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new Floor();
        result.init(json);
        return result;
    }
}

export interface IFloor {
    name: string;
    order: number;
    buildingId: string;
}

export class CustomerSearchDto implements ICustomerSearchDto {
    projectId: number;
    keyword: string;
    floorNo: string;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: ICustomerSearchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.keyword = data["keyword"];
            this.floorNo = data["floorNo"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): CustomerSearchDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerSearchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["keyword"] = this.keyword;
        data["floorNo"] = this.floorNo;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CustomerSearchDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerSearchDto {
    projectId: number;
    keyword: string;
    floorNo: string;
    skipCount: number;
    maxResultCount: number;
}

export class PagedResultDtoOfCustomerDto implements IPagedResultDtoOfCustomerDto {
    totalCount: number;
    items: CustomerDto[];

    constructor(data?: IPagedResultDtoOfCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCustomerDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCustomerDto {
    totalCount: number;
    items: CustomerDto[];
}

export class CustomerDto implements ICustomerDto {
    no: string;
    building: string;
    unit: string;
    house: string;
    floor: string;
    name: string;
    mobile: string;
    email: string;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.no = data["no"];
            this.building = data["building"];
            this.unit = data["unit"];
            this.house = data["house"];
            this.floor = data["floor"];
            this.name = data["name"];
            this.mobile = data["mobile"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["no"] = this.no;
        data["building"] = this.building;
        data["unit"] = this.unit;
        data["house"] = this.house;
        data["floor"] = this.floor;
        data["name"] = this.name;
        data["mobile"] = this.mobile;
        data["email"] = this.email;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    no: string;
    building: string;
    unit: string;
    house: string;
    floor: string;
    name: string;
    mobile: string;
    email: string;
}

export class DefectDetailModel implements IDefectDetailModel {
    id: number;
    displayId: string;
    defectDisplayNumber: string;
    projectId: string;
    location: string;
    floorId: number;
    floorName: string;
    roomTypeId: number;
    summary: string;
    description: string;
    statusCode: string;
    statusName: string;
    unitStatusCode: number;
    inspection: string;
    area: string;
    component: string;
    floorPlan: FloorPlanModel;
    reporterRole: string;
    reporterName: string;
    notes: DefectNoteModel[];
    sumbitTime: number;
    lastUpdateTime: number;
    customerName: string;
    defectLocation: DefectLocationModel;

    constructor(data?: IDefectDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayId = data["displayId"];
            this.defectDisplayNumber = data["defectDisplayNumber"];
            this.projectId = data["projectId"];
            this.location = data["location"];
            this.floorId = data["floorId"];
            this.floorName = data["floorName"];
            this.roomTypeId = data["roomTypeId"];
            this.summary = data["summary"];
            this.description = data["description"];
            this.statusCode = data["statusCode"];
            this.statusName = data["statusName"];
            this.unitStatusCode = data["unitStatusCode"];
            this.inspection = data["inspection"];
            this.area = data["area"];
            this.component = data["component"];
            this.floorPlan = data["floorPlan"] ? FloorPlanModel.fromJS(data["floorPlan"]) : <any>undefined;
            this.reporterRole = data["reporterRole"];
            this.reporterName = data["reporterName"];
            if (data["notes"] && data["notes"].constructor === Array) {
                this.notes = [];
                for (let item of data["notes"])
                    this.notes.push(DefectNoteModel.fromJS(item));
            }
            this.sumbitTime = data["sumbitTime"];
            this.lastUpdateTime = data["lastUpdateTime"];
            this.customerName = data["customerName"];
            this.defectLocation = data["defectLocation"] ? DefectLocationModel.fromJS(data["defectLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DefectDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new DefectDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayId"] = this.displayId;
        data["defectDisplayNumber"] = this.defectDisplayNumber;
        data["projectId"] = this.projectId;
        data["location"] = this.location;
        data["floorId"] = this.floorId;
        data["floorName"] = this.floorName;
        data["roomTypeId"] = this.roomTypeId;
        data["summary"] = this.summary;
        data["description"] = this.description;
        data["statusCode"] = this.statusCode;
        data["statusName"] = this.statusName;
        data["unitStatusCode"] = this.unitStatusCode;
        data["inspection"] = this.inspection;
        data["area"] = this.area;
        data["component"] = this.component;
        data["floorPlan"] = this.floorPlan ? this.floorPlan.toJSON() : <any>undefined;
        data["reporterRole"] = this.reporterRole;
        data["reporterName"] = this.reporterName;
        if (this.notes && this.notes.constructor === Array) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        data["sumbitTime"] = this.sumbitTime;
        data["lastUpdateTime"] = this.lastUpdateTime;
        data["customerName"] = this.customerName;
        data["defectLocation"] = this.defectLocation ? this.defectLocation.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectDetailModel();
        result.init(json);
        return result;
    }
}

export interface IDefectDetailModel {
    id: number;
    displayId: string;
    defectDisplayNumber: string;
    projectId: string;
    location: string;
    floorId: number;
    floorName: string;
    roomTypeId: number;
    summary: string;
    description: string;
    statusCode: string;
    statusName: string;
    unitStatusCode: number;
    inspection: string;
    area: string;
    component: string;
    floorPlan: FloorPlanModel;
    reporterRole: string;
    reporterName: string;
    notes: DefectNoteModel[];
    sumbitTime: number;
    lastUpdateTime: number;
    customerName: string;
    defectLocation: DefectLocationModel;
}

export class FloorPlanModel implements IFloorPlanModel {
    id: number;
    name: string;
    unitFloorPlanCount: number;
    floorPlanUrl: string;

    constructor(data?: IFloorPlanModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.unitFloorPlanCount = data["unitFloorPlanCount"];
            this.floorPlanUrl = data["floorPlanUrl"];
        }
    }

    static fromJS(data: any): FloorPlanModel {
        data = typeof data === 'object' ? data : {};
        let result = new FloorPlanModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unitFloorPlanCount"] = this.unitFloorPlanCount;
        data["floorPlanUrl"] = this.floorPlanUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new FloorPlanModel();
        result.init(json);
        return result;
    }
}

export interface IFloorPlanModel {
    id: number;
    name: string;
    unitFloorPlanCount: number;
    floorPlanUrl: string;
}

export class DefectNoteModel implements IDefectNoteModel {
    id: string;
    statusCode: string;
    statusName: string;
    reporterId: string;
    reporterName: string;
    reporterRole: string;
    description: string;
    sumbitTime: number;
    attachments: AttachmentModel[];

    constructor(data?: IDefectNoteModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.statusCode = data["statusCode"];
            this.statusName = data["statusName"];
            this.reporterId = data["reporterId"];
            this.reporterName = data["reporterName"];
            this.reporterRole = data["reporterRole"];
            this.description = data["description"];
            this.sumbitTime = data["sumbitTime"];
            if (data["attachments"] && data["attachments"].constructor === Array) {
                this.attachments = [];
                for (let item of data["attachments"])
                    this.attachments.push(AttachmentModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DefectNoteModel {
        data = typeof data === 'object' ? data : {};
        let result = new DefectNoteModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusCode"] = this.statusCode;
        data["statusName"] = this.statusName;
        data["reporterId"] = this.reporterId;
        data["reporterName"] = this.reporterName;
        data["reporterRole"] = this.reporterRole;
        data["description"] = this.description;
        data["sumbitTime"] = this.sumbitTime;
        if (this.attachments && this.attachments.constructor === Array) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectNoteModel();
        result.init(json);
        return result;
    }
}

export interface IDefectNoteModel {
    id: string;
    statusCode: string;
    statusName: string;
    reporterId: string;
    reporterName: string;
    reporterRole: string;
    description: string;
    sumbitTime: number;
    attachments: AttachmentModel[];
}

export class DefectLocationModel implements IDefectLocationModel {
    percentX: number;
    percentY: number;
    innerSequenceNumber: number;

    constructor(data?: IDefectLocationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.percentX = data["percentX"];
            this.percentY = data["percentY"];
            this.innerSequenceNumber = data["innerSequenceNumber"];
        }
    }

    static fromJS(data: any): DefectLocationModel {
        data = typeof data === 'object' ? data : {};
        let result = new DefectLocationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["percentX"] = this.percentX;
        data["percentY"] = this.percentY;
        data["innerSequenceNumber"] = this.innerSequenceNumber;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new DefectLocationModel();
        result.init(json);
        return result;
    }
}

export interface IDefectLocationModel {
    percentX: number;
    percentY: number;
    innerSequenceNumber: number;
}

export class PrintQrCodeCriteria implements IPrintQrCodeCriteria {
    projectName: string;
    unitInfoes: UnitInfo[];

    constructor(data?: IPrintQrCodeCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectName = data["projectName"];
            if (data["unitInfoes"] && data["unitInfoes"].constructor === Array) {
                this.unitInfoes = [];
                for (let item of data["unitInfoes"])
                    this.unitInfoes.push(UnitInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PrintQrCodeCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PrintQrCodeCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        if (this.unitInfoes && this.unitInfoes.constructor === Array) {
            data["unitInfoes"] = [];
            for (let item of this.unitInfoes)
                data["unitInfoes"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PrintQrCodeCriteria();
        result.init(json);
        return result;
    }
}

export interface IPrintQrCodeCriteria {
    projectName: string;
    unitInfoes: UnitInfo[];
}

export class UnitInfo implements IUnitInfo {
    building: string;
    unitNo: string;

    constructor(data?: IUnitInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.building = data["building"];
            this.unitNo = data["unitNo"];
        }
    }

    static fromJS(data: any): UnitInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UnitInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["building"] = this.building;
        data["unitNo"] = this.unitNo;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UnitInfo();
        result.init(json);
        return result;
    }
}

export interface IUnitInfo {
    building: string;
    unitNo: string;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    roleName: string;
    assignedProjects: string;
    permissionCodes: string[];

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.roleName = data["roleName"];
            this.assignedProjects = data["assignedProjects"];
            if (data["permissionCodes"] && data["permissionCodes"].constructor === Array) {
                this.permissionCodes = [];
                for (let item of data["permissionCodes"])
                    this.permissionCodes.push(item);
            }
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["roleName"] = this.roleName;
        data["assignedProjects"] = this.assignedProjects;
        if (this.permissionCodes && this.permissionCodes.constructor === Array) {
            data["permissionCodes"] = [];
            for (let item of this.permissionCodes)
                data["permissionCodes"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    roleName: string;
    assignedProjects: string;
    permissionCodes: string[];
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id: number;
    tenancyName: string;
    name: string;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string;
    name: string;
}

export class RolePermissionMatrixDto implements IRolePermissionMatrixDto {
    permissionCategory: string;
    categoryOrder: number;
    categoryDisplayName: string;
    permissionAssignments: PermissionAssignment[];

    constructor(data?: IRolePermissionMatrixDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.permissionCategory = data["permissionCategory"];
            this.categoryOrder = data["categoryOrder"];
            this.categoryDisplayName = data["categoryDisplayName"];
            if (data["permissionAssignments"] && data["permissionAssignments"].constructor === Array) {
                this.permissionAssignments = [];
                for (let item of data["permissionAssignments"])
                    this.permissionAssignments.push(PermissionAssignment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolePermissionMatrixDto {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionMatrixDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionCategory"] = this.permissionCategory;
        data["categoryOrder"] = this.categoryOrder;
        data["categoryDisplayName"] = this.categoryDisplayName;
        if (this.permissionAssignments && this.permissionAssignments.constructor === Array) {
            data["permissionAssignments"] = [];
            for (let item of this.permissionAssignments)
                data["permissionAssignments"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RolePermissionMatrixDto();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionMatrixDto {
    permissionCategory: string;
    categoryOrder: number;
    categoryDisplayName: string;
    permissionAssignments: PermissionAssignment[];
}

export class PermissionAssignment implements IPermissionAssignment {
    permissionName: string;
    isAssignedToContractor: boolean;
    isAssignedToCM: boolean;
    isAssignedToPMC: boolean;
    isAssignedToCS: boolean;
    isAssignedToTS: boolean;
    isAssignedToATOPM: boolean;
    isAssignedToAdmin: boolean;

    constructor(data?: IPermissionAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.permissionName = data["permissionName"];
            this.isAssignedToContractor = data["isAssignedToContractor"];
            this.isAssignedToCM = data["isAssignedToCM"];
            this.isAssignedToPMC = data["isAssignedToPMC"];
            this.isAssignedToCS = data["isAssignedToCS"];
            this.isAssignedToTS = data["isAssignedToTS"];
            this.isAssignedToATOPM = data["isAssignedToATOPM"];
            this.isAssignedToAdmin = data["isAssignedToAdmin"];
        }
    }

    static fromJS(data: any): PermissionAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["permissionName"] = this.permissionName;
        data["isAssignedToContractor"] = this.isAssignedToContractor;
        data["isAssignedToCM"] = this.isAssignedToCM;
        data["isAssignedToPMC"] = this.isAssignedToPMC;
        data["isAssignedToCS"] = this.isAssignedToCS;
        data["isAssignedToTS"] = this.isAssignedToTS;
        data["isAssignedToATOPM"] = this.isAssignedToATOPM;
        data["isAssignedToAdmin"] = this.isAssignedToAdmin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PermissionAssignment();
        result.init(json);
        return result;
    }
}

export interface IPermissionAssignment {
    permissionName: string;
    isAssignedToContractor: boolean;
    isAssignedToCM: boolean;
    isAssignedToPMC: boolean;
    isAssignedToCS: boolean;
    isAssignedToTS: boolean;
    isAssignedToATOPM: boolean;
    isAssignedToAdmin: boolean;
}

export class UserModel implements IUserModel {
    id: number;
    name: string;
    role: string;
    email: string;
    isActive: boolean;
    isEnable: boolean;
    createdDateTime: string;
    permissions: PermissionModel[];

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.role = data["role"];
            this.email = data["email"];
            this.isActive = data["isActive"];
            this.isEnable = data["isEnable"];
            this.createdDateTime = data["createdDateTime"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(PermissionModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["role"] = this.role;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        data["isEnable"] = this.isEnable;
        data["createdDateTime"] = this.createdDateTime;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserModel();
        result.init(json);
        return result;
    }
}

export interface IUserModel {
    id: number;
    name: string;
    role: string;
    email: string;
    isActive: boolean;
    isEnable: boolean;
    createdDateTime: string;
    permissions: PermissionModel[];
}

export class PermissionModel implements IPermissionModel {
    code: string;
    name: string;

    constructor(data?: IPermissionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PermissionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PermissionModel();
        result.init(json);
        return result;
    }
}

export interface IPermissionModel {
    code: string;
    name: string;
}

export class UserSearchModel implements IUserSearchModel {
    roleName: string;
    keyWord: string;
    skipCount: number;
    maxResultCount: number;

    constructor(data?: IUserSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleName = data["roleName"];
            this.keyWord = data["keyWord"];
            this.skipCount = data["skipCount"];
            this.maxResultCount = data["maxResultCount"];
        }
    }

    static fromJS(data: any): UserSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        data["keyWord"] = this.keyWord;
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserSearchModel();
        result.init(json);
        return result;
    }
}

export interface IUserSearchModel {
    roleName: string;
    keyWord: string;
    skipCount: number;
    maxResultCount: number;
}

export class PagedResultDtoOfUserModel implements IPagedResultDtoOfUserModel {
    totalCount: number;
    items: UserModel[];

    constructor(data?: IPagedResultDtoOfUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserModel();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserModel {
    totalCount: number;
    items: UserModel[];
}

export class UserRequestModel implements IUserRequestModel {
    userId: string;
    userName: string;
    role: string;
    email: string;

    constructor(data?: IUserRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.role = data["role"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): UserRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["role"] = this.role;
        data["email"] = this.email;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserRequestModel();
        result.init(json);
        return result;
    }
}

export interface IUserRequestModel {
    userId: string;
    userName: string;
    role: string;
    email: string;
}

export class RoleModel implements IRoleModel {
    name: string;
    displayName: string;
    accessLevelId: number;

    constructor(data?: IRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.accessLevelId = data["accessLevelId"];
        }
    }

    static fromJS(data: any): RoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["accessLevelId"] = this.accessLevelId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleModel();
        result.init(json);
        return result;
    }
}

export interface IRoleModel {
    name: string;
    displayName: string;
    accessLevelId: number;
}

export class ProjectSummaryModel implements IProjectSummaryModel {
    id: number;
    name: string;
    imageUrl: string;

    constructor(data?: IProjectSummaryModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): ProjectSummaryModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectSummaryModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ProjectSummaryModel();
        result.init(json);
        return result;
    }
}

export interface IProjectSummaryModel {
    id: number;
    name: string;
    imageUrl: string;
}

export class LoginRequestModel implements ILoginRequestModel {
    userName: string;
    password: string;
    isLoginAdmin: boolean;

    constructor(data?: ILoginRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.password = data["password"];
            this.isLoginAdmin = data["isLoginAdmin"];
        }
    }

    static fromJS(data: any): LoginRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["isLoginAdmin"] = this.isLoginAdmin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new LoginRequestModel();
        result.init(json);
        return result;
    }
}

export interface ILoginRequestModel {
    userName: string;
    password: string;
    isLoginAdmin: boolean;
}

export class TokenResponse implements ITokenResponse {
    accessToken: string;
    identityToken: string;
    tokenType: string;
    refreshToken: string;
    errorDescription: string;
    expiresIn: number;
    raw: string;
    json: any;
    exception: any;
    isError: boolean;
    errorType: TokenResponseErrorType;
    httpStatusCode: TokenResponseHttpStatusCode;
    httpErrorReason: string;
    error: string;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.identityToken = data["identityToken"];
            this.tokenType = data["tokenType"];
            this.refreshToken = data["refreshToken"];
            this.errorDescription = data["errorDescription"];
            this.expiresIn = data["expiresIn"];
            this.raw = data["raw"];
            if (data["json"]) {
                this.json = {};
                for (let key in data["json"]) {
                    if (data["json"].hasOwnProperty(key))
                        this.json[key] = data["json"][key];
                }
            }
            if (data["exception"]) {
                this.exception = {};
                for (let key in data["exception"]) {
                    if (data["exception"].hasOwnProperty(key))
                        this.exception[key] = data["exception"][key];
                }
            }
            this.isError = data["isError"];
            this.errorType = data["errorType"];
            this.httpStatusCode = data["httpStatusCode"];
            this.httpErrorReason = data["httpErrorReason"];
            this.error = data["error"];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["identityToken"] = this.identityToken;
        data["tokenType"] = this.tokenType;
        data["refreshToken"] = this.refreshToken;
        data["errorDescription"] = this.errorDescription;
        data["expiresIn"] = this.expiresIn;
        data["raw"] = this.raw;
        if (this.json) {
            data["json"] = {};
            for (let key in this.json) {
                if (this.json.hasOwnProperty(key))
                    data["json"][key] = this.json[key];
            }
        }
        if (this.exception) {
            data["exception"] = {};
            for (let key in this.exception) {
                if (this.exception.hasOwnProperty(key))
                    data["exception"][key] = this.exception[key];
            }
        }
        data["isError"] = this.isError;
        data["errorType"] = this.errorType;
        data["httpStatusCode"] = this.httpStatusCode;
        data["httpErrorReason"] = this.httpErrorReason;
        data["error"] = this.error;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TokenResponse();
        result.init(json);
        return result;
    }
}

export interface ITokenResponse {
    accessToken: string;
    identityToken: string;
    tokenType: string;
    refreshToken: string;
    errorDescription: string;
    expiresIn: number;
    raw: string;
    json: any;
    exception: any;
    isError: boolean;
    errorType: TokenResponseErrorType;
    httpStatusCode: TokenResponseHttpStatusCode;
    httpErrorReason: string;
    error: string;
}

export class ActivateAccountRequestModel implements IActivateAccountRequestModel {
    email: string;
    initialPassword: string;
    newPassword: string;

    constructor(data?: IActivateAccountRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.initialPassword = data["initialPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ActivateAccountRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["initialPassword"] = this.initialPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ActivateAccountRequestModel();
        result.init(json);
        return result;
    }
}

export interface IActivateAccountRequestModel {
    email: string;
    initialPassword: string;
    newPassword: string;
}

export class ResetPasswordRequestModel implements IResetPasswordRequestModel {
    email: string;
    newPassword: string;
    verificationCode: string;

    constructor(data?: IResetPasswordRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.newPassword = data["newPassword"];
            this.verificationCode = data["verificationCode"];
        }
    }

    static fromJS(data: any): ResetPasswordRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["verificationCode"] = this.verificationCode;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ResetPasswordRequestModel();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordRequestModel {
    email: string;
    newPassword: string;
    verificationCode: string;
}

export enum TokenResponseErrorType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum TokenResponseHttpStatusCode {
    _100 = 100, 
    _101 = 101, 
    _200 = 200, 
    _201 = 201, 
    _202 = 202, 
    _203 = 203, 
    _204 = 204, 
    _205 = 205, 
    _206 = 206, 
    _300 = 300, 
    _301 = 301, 
    _302 = 302,  
    _303 = 303, 
    _304 = 304, 
    _305 = 305, 
    _306 = 306, 
    _307 = 307, 
    _400 = 400, 
    _401 = 401, 
    _402 = 402, 
    _403 = 403, 
    _404 = 404, 
    _405 = 405, 
    _406 = 406, 
    _407 = 407, 
    _408 = 408, 
    _409 = 409, 
    _410 = 410, 
    _411 = 411, 
    _412 = 412, 
    _413 = 413, 
    _414 = 414, 
    _415 = 415, 
    _416 = 416, 
    _417 = 417, 
    _426 = 426, 
    _500 = 500, 
    _501 = 501, 
    _502 = 502, 
    _503 = 503, 
    _504 = 504, 
    _505 = 505, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}
